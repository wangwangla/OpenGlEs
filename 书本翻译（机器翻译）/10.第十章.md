# 片段着色器

Fragment Shaders

在第9章“纹理”中，我们向您介绍了在片段着色器中创建和应用纹理的基础知识。在这一章中，我们提供了更多关于片段着色器的细节，并描述了它的一些用途。特别是，我们关注如何使用片段着色器实现固定函数技术。本章涵盖的主题包括:

In Chapter 9, “Texturing,” we introduced you to the basics of creating and  applying textures in the fragment shader. In this chapter, we provide more  details on the fragment shader and describe some of its uses. In particular, we  focus on how to implement fixed function techniques using the fragment shader.  The topics we cover in this chapter include:

- 修复了函数片段着色器。

  Fixed function fragment shaders.

- 片段着色器概述。

  Fragment shader overview.

回到图10-1中的管道图，我们已经讨论了管道的顶点着色器、图元装配和光栅化阶段。我们已经讨论过在片段着色器中使用纹理。现在，我们将重点放在管道的片段着色器部分，并填写编写片段着色器的其余细节。

Returning to our pipeline diagram in Figure 10-1, we have covered the vertex  shader, primitive assembly, and rasterization stages of the pipeline. We have  talked about using textures in the fragment shader. Now, we focus on the  fragment shader portion of the pipeline and fill in the remaining details on  writing fragment shaders.

## 固定功能片段着色器

Fixed Function Fragment Shaders

对于不熟悉可编程片段管道但使用过OpenGL  ES(或桌面OpenGL)早期版本的读者来说，您可能熟悉固定函数片段管道。在深入片段着色器的细节之前，我们认为有必要简要回顾一下旧的固定函数片段管道。这将让您了解旧的固定函数管道是如何映射到片段着色器的。在进入更高级的片段编程技术之前，这是一个很好的开始。

For readers who are new to the programmable fragment pipeline but have worked  with a previous version of OpenGL ES (or desktop OpenGL), you are probably  familiar with the fixed function fragment pipeline. Before diving into details  of the fragment shader, we think it is worthwhile to briefly review the old  fixed function fragment pipeline. This will give you an understanding of how the  old fixed function pipeline maps into fragment shaders. It’s a good way to start  before moving into more advanced fragment programming techniques.

在OpenGL  ES  1.1(和固定功能桌面OpenGL)中，可以用来确定如何将各种输入组合到片段着色器的等式非常有限。在固定函数管道中，基本上有三个输入可以使用:插值顶点颜色、纹理颜色和常量颜色。顶点颜色通常包含预先计算的颜色或顶点光照计算的结果。

In OpenGL ES 1.1 (and fixed function desktop OpenGL), you had a very limited  set of equations that could be used to determine how to combine the various  inputs to the fragment shader. In the fixed function pipeline, you essentially  had three inputs you could use: the interpolated vertex color, the texture  color, and the constant color. The vertex color would typically hold either a  precomputed color or the result of the vertex lighting computation.

纹理颜色来自于从任何纹理获取使用图元的纹理坐标绑定，并且可以为每个纹理单元设置恒定的颜色。

The texture color came from fetching from whichever texture was bound using the primitive’s texture coordinates and the constant color  could be set for each texture unit.

您可以用来将这些输入组合在一起的方程组非常有限。例如，在OpenGL  ES 1.1中，表10-1中列出的方程是可用的。

The set of equations you could use to combine these inputs together was quite  limited. For example, in OpenGL ES 1.1 the equations listed in Table 10-1 were  available.

<img src="images/image-20210327091731680.png" alt="image-20210327091731680" style="zoom:50%;" />



这些方程的输入可以来自顶点颜色、纹理颜色或恒定颜色。事实上，人们可以获得大量有趣的效果，即使是用这有限的方程组。然而，这远不是可编程的，因为片段流水线只能以一组非常固定的方式进行配置。

The inputs A, B, and C to these equations could come from the vertex color,  texture color, or constant color. There actually was a great number of  interesting effects one could achieve, even with this limited set of equations.  However, this was far from programmable, as the fragment pipeline could only be  configured in a very fixed set of ways.

那我们为什么要在这里回顾呢？它有助于理解如何使用着色器实现传统的固定函数技术。例如，假设我们已经配置了一个单一的基础纹理贴图的固定功能管道，我们想通过顶点颜色来调整它。在固定函数OpenGL  ES(或OpenGL)中，我们将启用单个纹理单元，选择一个调制的组合方程，并将方程的输入设置为来自顶点颜色和纹理颜色。这里提供了OpenGL ES  1.1中做到这一点的代码，供参考。

So why are we reviewing this here? It helps give an understanding of how  traditional fixed function techniques can be achieved with shaders. For example,  let’s say we had configured the fixed function pipeline with a single base  texture map that we wanted to modulate by the vertex color. In fixed function  OpenGL ES (or OpenGL), we would enable a single texture unit, choose a combine  equation of MODULATE, and set up the inputs to the equation to come from the  vertex color and texture color. The code to do this in OpenGL ES 1.1 is provided  here for reference.

```c
glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_COMBINE);
glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_RGB, GL_MODULATE);
glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_RGB, GL_PRIMARY_COLOR);
glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_RGB, GL_TEXTURE);
glTexEnvi(GL_TEXTURE_ENV, GL_COMBINE_ALPHA, GL_MODULATE);
glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE0_ALPHA, GL_PRIMARY_COLOR);
glTexEnvi(GL_TEXTURE_ENV, GL_SOURCE1_ALPHA, GL_TEXTURE);
```

此代码配置固定函数管道，以在原色(顶点颜色)和纹理颜色之间执行调制(A  × B)。如果这段代码对您没有意义，请不要担心，因为OpenGL ES  2.0中不存在这些。我们在这里试图说明的一点是，这将如何映射到一个片段着色器。在片段着色器中，同样的计算可以按如下方式完成。

This code configures the fixed function pipeline to perform a modulate (A × B)  between the primary color (the vertex color) and the texture color. If this code  doesn’t make sense to you, don’t worry, as none of this exists in OpenGL ES 2.0.  The point we are trying to make here is to show how this would map to a fragment  shader. In a fragment shader, this same computation could be accomplished as  follows.

```java
precision mediump float;
uniform sampler2D s_tex0;
varying vec2 v_texCoord;
varying vec4 v_primaryColor;
void main()
{
   gl_FragColor = texture2D(s_tex0, v_texCoord) * v_primaryColor;
}precision mediump float;
uniform sampler2D s_tex0;
varying vec2 v_texCoord;
varying vec4 v_primaryColor;
void main()
{
   gl_FragColor = texture2D(s_tex0, v_texCoord) * v_primaryColor;
}
```

片段着色器执行与固定函数设置完全相同的操作。从采样器(绑定到纹理单元0)获取纹理值，并使用2D纹理坐标来查找该值。然后，纹理提取的结果乘以v_primaryColor，这是一个从顶点着色器传入的可变值。在这种情况下，顶点着色器会将颜色传递给片段着色器。

The fragment shader performs the exact same operations that would be performed  by the fixed function setup. The texture value is fetched from a sampler (that  is bound to texture unit 0) and a 2D texture coordinate is used to look up that  value. Then, the result of that texture fetch is multiplied by v_primaryColor, a  varying value that is passed in from the vertex shader. In this case, the vertex  shader would have passed the color through to the fragment shader.

可以编写一个片段着色器来执行与任何可能的固定函数纹理组合设置相同的计算。当然，编写比固定函数允许的更复杂和更多样的计算的着色器也是可能的。然而，这一节的重点仅仅是为了说明我们是如何从固定功能过渡到可编程着色器的。现在，我们开始关注片段着色器的一些细节。

It is possible to write a fragment shader that would perform the equivalent  computation as any possible fixed function texture combine setup. It is also, of  course, possible to write shaders with much more complex and varied computations  than just fixed function would allow. However, the point of this section was  just to drive home the point of how we have transitioned from fixed function to  programmable shaders. Now, we begin to look at some specifics of fragment  shaders.

## 片段着色器的概括

​	