# 顶点着色器

Vertex Shaders

本章介绍OpenGL  ES 2.0可编程顶点流水线。图8-1说明了OpenGL ES 2.0可编程流水线。图8-1中的阴影框表示OpenGL ES  2.0中的可编程阶段。在本章中，我们讨论顶点着色器阶段。顶点着色器可用于执行传统的基于顶点的操作，例如通过矩阵变换位置、计算光照方程以生成反常颜色，以及生成或变换纹理坐标。

This chapter describes the OpenGL ES 2.0 programmable vertex pipeline. Figure  8-1 illustrates the OpenGL ES 2.0 programmable pipeline. The shaded boxes in  Figure 8-1 indicate the programmable stages in OpenGL ES 2.0. In this chapter we  discuss the vertex shader stage. Vertex shaders can be used to do traditional  vertex-based operations such as transforming the position by a matrix, computing  the lighting equation to generate a pervertex color, and generating or  transforming texture coordinates.

<img src="images/image-20210324221133236.png" alt="image-20210324221133236" style="zoom:50%;" />





前几章，特别是第5章，“OpenGL  ES着色语言”和第6章，“顶点属性、顶点数组和缓冲对象”，讨论了如何指定顶点属性和统一输入，并对OpenGL ES  2.0着色语言进行了很好的描述。在第7章“图元组装和光栅化”中，我们讨论了光栅化阶段如何使用顶点着色器的输出(称为可变变量)来生成每个片段的值，然后将这些值输入到片段着色器。在本章中，我们从顶点着色器的高级概述开始，包括它的输入和输出。然后，我们讨论OpenGL  ES 2.0着色语言施加的一些限制，并描述在编写需要跨多个OpenGL ES  2.0实现移植的着色器时要记住的要点。然后我们通过讨论几个例子来描述如何编写顶点着色器。这些示例描述了一些常见的用例，例如用模型视图和投影矩阵转换顶点位置、生成逐顶点漫反射和镜面反射颜色的顶点照明示例、纹理坐标生成和顶点蒙皮。我们希望这些例子能帮助读者更好地理解如何编写顶点着色器，记住尽可能使顶点着色器便携的规则，以及顶点着色器可以有多大的上限。最后但同样重要的是，我们描述了一个实现OpenGL  ES 1.1固定功能顶点流水线的顶点着色器。这两个着色器还应该让读者很好地理解实现OpenGL ES 2.0的第一代手持设备将支持的顶点着色器的复杂性。

The previous chapters, specifically Chapter 5, “OpenGL ES Shading Language,”  and Chapter 6, “Vertex Attributes, Vertex Arrays, and Buffer Objects,” discussed  how to specify the vertex attribute and uniform inputs and also gave a good  description of the OpenGL ES 2.0 shading language. In Chapter 7, “Primitive  Assembly and Rasterization,” we discussed how the output of the vertex shader,  referred to as varying variables, is used by the rasterization stage to generate  per-fragment values, which are then input to the fragment shader. In this  chapter we begin with a high-level overview of a vertex shader including its  inputs and outputs. We then discuss some of the limitations imposed by the  OpenGL ES 2.0 shading language and describe points to keep in mind when writing  shaders that need to be portable across multiple OpenGL ES 2.0 implementations.  We then describe how to write vertex shaders by discussing a few examples. These  examples describe common use cases such as transforming a vertex position with a  model view and projection matrix, examples of vertex lighting that generate  per-vertex diffuse and specular colors, texture coordinate generation, and  vertex skinning. We hope that these examples help the reader get a good idea of  how to write vertex shaders, rules to keep in mind to make vertex shaders  portable as much as possible, and an upper limit on how big vertex shaders can  be. Last but not least, we describe a vertex shader that implements the OpenGL  ES 1.1 fixed function vertex pipeline. These two shaders should also give the  reader a good understanding of the complexity of vertex shaders that will be  supported by the first generation of handheld devices that implement OpenGL ES  2.0.

## 顶点着色器概述

Vertex Shader Overview

顶点着色器提供了一种对顶点进行操作的通用可编程方法。图8-2显示了顶点着色器的输入和输出。顶点着色器的输入包括以下内容:

The vertex shader provides a general-purpose programmable method for operating  on vertices. Figure 8-2 shows the inputs and outputs of a vertex shader. The  inputs to the vertex shader consist of the following:

- 属性—使用顶点数组提供的每个顶点的数据。

  Attributes—Per-vertex data supplied using vertex arrays.

- 统一-顶点着色器使用的恒定数据。

  Uniforms—Constant data used by the vertex shader.

- 着色器程序-顶点着色器程序源代码或可执行文件，描述将在顶点上执行的操作。

  Shader program—Vertex shader program source code or executable that describes  the operations that will be performed on the vertex.

顶点着色器的输出称为可变变量。在图元光栅化阶段，为每个生成的片段计算这些变量，并将其作为输入传递给片段着色器。

The outputs of the vertex shader are called varying variables. In the  primitive rasterization stage, these variables are computed for each generated  fragment and are passed in as inputs to the fragment shader.

<img src="images/image-20210324222011002.png" alt="image-20210324222011002" style="zoom:50%;" />



## 顶点着色器内置变量

Vertex Shader Built-In Variables

顶点着色器的内置变量可以分为由顶点着色器输出的特殊变量、统一状态(如深度范围)和指定最大值(如属性数量、变量数量和统一数量)的常数。

The built-in variables of a vertex shader can be categorized into special  variables that are output by the vertex shader, uniform state such as depth  range, and constants that specify maximum values such as the number of  attributes, number of varyings, and number of uniforms.

### 内置特殊变量

Built-In Special Variables

OpenGL  ES 2.0具有内置的特殊变量，这些变量要么由顶点着色器输出，然后成为片段着色器的输入，要么由片段着色器输出。顶点着色器可用的内置特殊变量如下:

OpenGL ES 2.0 has built-in special variables that are either output by the  vertex shader that then become input to the fragment shader, or are output by  the fragment shader. The built-in special variables available to the vertex  shader are as follows:

- GL _POSITION-位置用于输出片段坐标中的顶点位置。gl_Position值由裁剪和视口阶段用来执行图元的适当裁剪，并将顶点位置从裁剪坐标转换为屏幕坐标。

  gl_Position—gl_Position is used to output the vertex position in clip  coordinates. The gl_Position values are used by the clipping and viewport stages  to perform appropriate clipping of primitives and convert the vertex position  from clip coordinates to screen coordinates.

- gl_PointSize—gl_PointSize用于以像素为单位写入点精灵的大小。渲染点精灵时使用gl_PointSize。然后，顶点着色器输出的gl_PointSize值被箝位到OpenGL  ES 2.0实现支持的混叠点大小范围内。gl_PointSize是使用mediump精度限定符声明的浮点变量。

  gl_PointSize—gl_PointSize is used to write the size of the point sprite in  pixels. gl_PointSize is used when point sprites are rendered. The gl_PointSize  value output by a vertex shader is then clamped to the aliased point size range  supported by the OpenGL ES 2.0 implementation. gl_PointSize is a floating-point  variable declared using the mediump precision qualifier.

- 这个特殊的变量，虽然不是由顶点着色器直接编写的，但是是基于顶点着色器生成的位置值和渲染的图元类型生成的。gl_FrontFacing是一个布尔变量。

  gl_FrontFacing—This special variable, although not directly written by the  vertex shader, is generated based on the position values generated by the vertex  shader and primitive type being rendered. gl_FrontFacing is a boolean  variable.

## 内置统一状态

Built-In Uniform State

顶点着色器中唯一可用的内置统一状态是窗口坐标中的深度范围。这是由内置的统一名称gl  _ DepthRange给出的，它被声明为gl _ DepthRangeParameters类型的统一。

The only built-in uniform state available inside a vertex shader is the depth  range in window coordinates. This is given by the built-in uniform name  gl_DepthRange, which is declared as a uniform of type  gl_DepthRangeParameters.

```java
struct gl_DepthRangeParameters {
   highp float near; // near Z
   highp float far;  // far Z
   highp float diff; // far - near
}
uniform gl_DepthRangeParameters gl_DepthRange;
```

### 内置常数



Built-In Constants

顶点着色器中还有以下内置常量

The following built-in constants are also available inside the vertex  shader

```c
const medump int GL _ maxvertices = 8；
const medump int GL _ maxverticalxuriormvector = 128；
const mid UMP int GL _ maxvarying vectors = 8；
const medump int GL _ maxverticaltextureimageunits = 0；
const average UMP int GL _ maxcombinationed texture units = 8；
```

内置常数描述了以下最大项:

The built-in constants describe the following maximum terms:

- 这是可以指定的顶点属性的最大数量。所有ES  2.0实现支持的最小值是8

  gl_MaxVertexAttribs—This is the maximum number of vertex attributes that can  be specified. The minimum value supported by all ES 2.0 implementations is  eight