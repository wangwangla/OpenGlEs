# EGL简介

3.An Introduction to EGL.

在第二章“你好，三角形:一个OpenGL  ES 2.0的例子”中，我们使用OpenGL ES  2.0在一个窗口中画了一个三角形，但是我们使用了一些自己设计的自定义函数来打开和管理这个窗口。虽然这简化了我们的例子，但它掩盖了您可能需要如何在自己的系统上使用OpenGL  ES 2.0。

In Chapter 2, “Hello, Triangle: An OpenGL ES 2.0 Example,” we drew a triangle  into a window using OpenGL ES 2.0, but we used some custom functions of our own  design to open and manage the window. Although that simplifies our examples, it  obscures how you might need to work with OpenGL ES 2.0 on your own  systems.

作为由Khronos集团提供的用于开发内容的应用编程接口系列的一部分，一个(大部分)独立于平台的应用编程接口，EGL，可用于管理绘图表面(窗口只是一种类型；其他的我们以后再说)。EGL提供以下机制:

As part of the family of APIs provided by the Khronos Group for developing  content, a (mostly) platform-independent API, EGL, is available for managing  drawing surfaces (windows are just one type; we’ll talk about others later). EGL  provides the mechanisms for the following:

- 与系统的本地窗口系统通信。

  Communicating with the native windowing system of your system.

- 查询可用的工程图曲面类型和配置。

  Querying the available types and configurations of drawing surfaces.

- 创建绘图表面。

  Creating drawing surfaces.

- 在OpenGL  ES 2.0和其他图形渲染API(如OpenVG，或您的窗口系统的本机绘图命令)之间同步渲染。

  Synchronizing rendering between OpenGL ES 2.0 and other graphicsrendering APIs  (like OpenVG, or the native drawing commands of your windowing  system).

- 管理渲染资源，如纹理贴图。

  Managing rendering resources such as texture maps.

在本章中，我们将介绍打开一个窗口所需的基础知识。当我们描述其他操作时，比如创建纹理贴图，我们讨论必要的EGL命令。

We introduce the fundamentals required to open a window in this chapter. As we  describe other operations, such as creating a texture map, we discuss the  necessary EGL commands.

## 与窗口系统通信

Communicating with the Windowing System.

EGL在OpenGL  ES  2.0(和其他Khronos图形应用编程接口)和运行在您计算机上的本机窗口系统之间提供了一个“粘合剂”层，如GNU/Linux系统上常见的X窗口系统、微软窗口或麦克OS  X的石英。在EGL能够确定什么类型的绘图表面，或者底层系统的任何其他特性之前，它需要打开与窗口系统的通信通道。

EGL provides a “glue” layer between OpenGL ES 2.0 (and other Khronos graphics  APIs) and the native windowing system running on your computer, like the X  Window System common on GNU/Linux systems, Microsoft Windows, or Mac OS X’s  Quartz. Before EGL can determine what types of drawing surfaces, or any other  characteristics of the underlying system for that matter, it needs to open a  communications channel with the windowing system.

因为每个窗口系统都有不同的语义，EGL提供了一个基本的不透明类型——EGLDisplay——它封装了所有与本地窗口系统接口的系统依赖。任何使用EGL的应用程序需要做的第一个操作是创建并初始化与本地EGL显示器的连接。这是在两个调用序列中完成的，如示例3-1所示。

Because every windowing system has different semantics, EGL provides a basic  opaque type—the EGLDisplay—that encapsulates all of the system dependencies for  interfacing with the native windowing system. The first operation that any  application using EGL will need to do is create and initialize a connection with  the local EGL display. This is done in a two-call sequence, as shown in Example  3-1.

```c
Example 3-1 Initializing EGL
EGLint  majorVersion;
EGLint  minorVersion;
EGLDisplay  display;
display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
if(display == EGL_NO_DISPLAY)
{
   // Unable to open connection to local windowing system
}
if(!eglInitialize(display, &majorVersion, &minorVersion))
{
   // Unable to initialize EGL. Handle and recover
}
```

要打开与EGL显示服务器的连接，请调用

To open a connection to the EGL display server, call.

<img src="images/image-20210317080356373.png" alt="image-20210317080356373" style="zoom:50%;" />

EGLNativeDisplayType被定义为匹配本机窗口系统的显示类型。例如，在微软视窗系统上，一个活动显示类型将被定义为一个HDC——一个微软视窗设备上下文的句柄。但是，为了便于将代码移动到不同的操作系统和平台，令牌EGL_DEFAULT_DISPLAY被接受，并将返回到默认本机显示的连接，就像我们所做的那样。

EGLNativeDisplayType is defined to match the native window system’s display  type. On Microsoft Windows, for example, an EGLNativeDisplayType would be  defined to be an HDC—a handle to the Microsoft Windows device context. However,  to make it easy to move your code to different operating systems and platforms,  the token EGL_DEFAULT_DISPLAY is accepted and will return a connection to the  default native display, as we did.

如果显示连接不可用，则显示将返回EGL_NO_DISPLAY。此错误表明EGL不可用，您将无法使用OpenGL ES 2.0

If a display connection isn’t available, eglGetDisplay will return  EGL_NO_DISPLAY. This error indicates that EGL isn’t available, and you won’t be  able to use OpenGL ES 2.0。

在我们继续讨论更多的EGL操作之前，我们需要简要描述EGL如何处理并向您的应用程序报告错误。

Before we continue discussing more EGL operation, we need to briefly describe  how EGL processes and reports errors to your application.

## 检查错误

Checking for Errors

EGL的大多数函数成功时返回EGL为真，否则返回EGL为假。然而，EGL不仅仅会告诉你如果通话失败，它还会记录一个错误来指出失败的原因。但是，错误代码不会直接返回给您；您需要显式查询EGL的错误代码，这可以通过调用

Most functions in EGL return EGL_TRUE when successful and EGL_FALSE otherwise.  However, EGL will do more than just tell you if the call failed, it will record  an error to indicate the reason for failure. However, that error code isn’t  returned to you directly; you need to query EGL explicitly for the error code,  which you can do by calling

<img src="images/image-20210317080714968.png" alt="image-20210317080714968" style="zoom:50%;" />、

您可能想知道为什么这是一种谨慎的方法，而不是在调用完成时直接返回错误代码。虽然我们从不鼓励忽略函数返回代码，但允许可选的错误代码恢复可以减少应用程序中被验证为正常工作的冗余代码。您当然应该在开发和调试期间，以及在关键应用程序中的所有时间检查错误，但是一旦您确信您的应用程序按预期工作，您就可以减少错误检查。

You might wonder why this is a prudent approach, as compared to directly  returning the error code when the call completes. Although we never encourage  ignoring function return codes, allowing optional error code recovery reduces  redundant code in applications verified to work properly. You should certainly  check for errors during development and debugging, and all the time in critical  applications, but once you’re convinced your application is working as expected,  you can likely reduce your error checking.

## 初始化EGL

Initializing EGL

一旦您成功地打开了一个连接，EGL需要初始化，这是通过调用

Once you’ve successfully opened a connection, EGL needs to be initialized,  which is done by calling

<img src="images/image-20210317080909770.png" alt="image-20210317080909770" style="zoom:50%;" />

这将初始化EGL的内部数据结构，并返回EGL实现的主要和次要版本号。如果EGL无法初始化，此调用将返回EGL  _假，并将EGL的错误代码设置为:

This initializes EGL’s internal data structures and returns the major and  minor version numbers of the EGL implementation. If EGL is unable to be  initialized, this call will return EGL_FALSE, and set EGL’s error code  to:

- 如果DISPLAY没有指定有效的EGLDisplay，则显示EGL。

  EGL_BAD_DISPLAY if display doesn’t specify a valid EGLDisplay. 

- 如果EGL不能被初始化，则EGL不能被初始化。

  EGL_NOT_INITIALIZED if the EGL cannot be initialized.

## 确定可用的表面配置

Determining the Available Surface Configurations

一旦我们初始化了EGL，我们就能够确定哪些类型和配置的渲染表面是可用的。有两种方法可以解决这个问题:

Once we’ve initialized EGL, we’re able to determine what types and  configurations of rendering surfaces are available to us. There are two ways to  go about this:

- 查询每一个曲面配置，自己寻找最佳选择。

  Query every surface configuration and find the best choice  ourselves.

- 指定一组要求，让EGL推荐最佳匹配。

  Specify a set of requirements and let EGL make a recommendation for the best  match.

**表面有两种方式，一种是自己进行选择合适的，一种是通过EGL自己选择最优的。**

在许多情况下，第二个选项更容易实现，并且很可能会产生您使用第一个选项会发现的结果。无论是哪种情况，EGL都会返回一个EGLConfig，它是一个EGLinternal数据结构的标识符，该数据结构包含关于特定表面及其特征的信息，例如每个颜色分量的位数，或者是否有与该EGLConfig相关联的深度缓冲区。您可以使用eglGetConfigAttribute函数查询EGLConfig的任何属性，我们稍后将对此进行描述。

In many situations, the second option is simpler to implement, and most likely  yields what you would have found using the first option. In either case, EGL  will return an EGLConfig, which is an identifier to an EGLinternal data  structure that contains information about a particular surface and its  characteristics, such as number of bits for each color component, or if there’s  a depth buffer associated with that EGLConfig. Y ou can query any of the  attributes of an EGLConfig, using the eglGetConfigAttribute function, which we  describe later.

要查询底层窗口系统支持的所有EGL表面配置，请调用

To query all EGL surface configurations supported by the underlying windowing  system, call

<img src="images/image-20210318221820759.png" alt="image-20210318221820759" style="zoom:50%;" />

如果调用成功，返回EGL  _真。

which returns EGL_TRUE if the call succeeded.

有两种方法可以调用eglGetConfigs:首先，如果您为配置的值指定空，系统将返回EGL  _真并将numConfigs设置为可用EGLConfigs的数量。不会返回关于系统中任何EGLConfigs的附加信息，但是知道可用配置的数量允许您分配足够的内存来获取整个EGLConfigs集，如果您愿意的话。

There are two ways to call eglGetConfigs: First, if you specify NULL for the  value of configs, the system will return EGL_TRUE and set numConfigs to the  number of available EGLConfigs. No additional information about any of the  EGLConfigs in the system is returned, but knowing the number of available  configurations allows you to allocate enough memory to get the entire set of  EGLConfigs, should you care to.

或者，也许更有用的是，您可以分配一个未初始化的EGLConfig值数组，并将这些值作为Configs参数传递给eglGetConfigs。将maxReturnConfigs设置为您分配的数组的大小，这也将指定将返回的最大配置数。当调用完成时，numConfigs将被更新为配置中已修改的条目数。然后，您可以开始处理返回列表，查询配置的特征，以确定哪一个最符合我们的需求。

Alternatively, and perhaps more useful, is that you can allocate an array of  uninitialized EGLConfig values, and pass those into eglGetConfigs as the configs  parameter. Set maxReturnConfigs to the size of the array you allocated, which  will also specify the maximum number of configs that will be returned. When the  call completes, numConfigs will be updated with the number of entries in configs  that were modified. You can then begin processing the list of returns, querying  the characteristics of the configurations to determine which one matches our  needs the best.

## 查询配置属性

Querying EGLConfig Attributes

我们现在描述EGL与一个EGLConfig关联的值，以及如何检索这些值。

We now describe the values that EGL associates with an EGLConfig, and how you  can retrieve those values.

一个EGL配置包含了提供的关于一个表面的所有信息。这包括关于可用颜色数量、与配置相关的附加缓冲区(如深度和模板缓冲区，我们稍后讨论)、表面类型和许多其他特征的信息。接下来是一个可以从EGLConfig查询的所有属性的列表。在本章中，我们只讨论其中的一部分，但是我们在表3-1中提供了整个列表作为参考。

An EGLConfig contains all of the information about a surface made available by  EGL. This includes information about the number of available colors, additional  buffers associated with the configuration (like depth and stencil buffers, which  we discuss later), the type of surfaces, and numerous other characteristics.  What follows is a list of all of the attributes that can be queried from an  EGLConfig. We only discuss a subset of these in this chapter, but we provide the  entire list in Table 3-1 as a reference.