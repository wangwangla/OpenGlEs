# EGL简介

3.An Introduction to EGL.

在第二章“你好，三角形:一个OpenGL  ES 2.0的例子”中，我们使用OpenGL ES  2.0在一个窗口中画了一个三角形，但是我们使用了一些自己设计的自定义函数来打开和管理这个窗口。虽然这简化了我们的例子，但它掩盖了您可能需要如何在自己的系统上使用OpenGL  ES 2.0。

In Chapter 2, “Hello, Triangle: An OpenGL ES 2.0 Example,” we drew a triangle  into a window using OpenGL ES 2.0, but we used some custom functions of our own  design to open and manage the window. Although that simplifies our examples, it  obscures how you might need to work with OpenGL ES 2.0 on your own  systems.

作为由Khronos集团提供的用于开发内容的应用编程接口系列的一部分，一个(大部分)独立于平台的应用编程接口，EGL，可用于管理绘图表面(窗口只是一种类型；其他的我们以后再说)。EGL提供以下机制:

As part of the family of APIs provided by the Khronos Group for developing  content, a (mostly) platform-independent API, EGL, is available for managing  drawing surfaces (windows are just one type; we’ll talk about others later). EGL  provides the mechanisms for the following:

- 与系统的本地窗口系统通信。

  Communicating with the native windowing system of your system.

- 查询可用的工程图曲面类型和配置。

  Querying the available types and configurations of drawing surfaces.

- 创建绘图表面。

  Creating drawing surfaces.

- 在OpenGL  ES 2.0和其他图形渲染API(如OpenVG，或您的窗口系统的本机绘图命令)之间同步渲染。

  Synchronizing rendering between OpenGL ES 2.0 and other graphicsrendering APIs  (like OpenVG, or the native drawing commands of your windowing  system).

- 管理渲染资源，如纹理贴图。

  Managing rendering resources such as texture maps.

在本章中，我们将介绍打开一个窗口所需的基础知识。当我们描述其他操作时，比如创建纹理贴图，我们讨论必要的EGL命令。

We introduce the fundamentals required to open a window in this chapter. As we  describe other operations, such as creating a texture map, we discuss the  necessary EGL commands.

## 与窗口系统通信

Communicating with the Windowing System.

EGL在OpenGL  ES  2.0(和其他Khronos图形应用编程接口)和运行在您计算机上的本机窗口系统之间提供了一个“粘合剂”层，如GNU/Linux系统上常见的X窗口系统、微软窗口或麦克OS  X的石英。在EGL能够确定什么类型的绘图表面，或者底层系统的任何其他特性之前，它需要打开与窗口系统的通信通道。

EGL provides a “glue” layer between OpenGL ES 2.0 (and other Khronos graphics  APIs) and the native windowing system running on your computer, like the X  Window System common on GNU/Linux systems, Microsoft Windows, or Mac OS X’s  Quartz. Before EGL can determine what types of drawing surfaces, or any other  characteristics of the underlying system for that matter, it needs to open a  communications channel with the windowing system.

因为每个窗口系统都有不同的语义，EGL提供了一个基本的不透明类型——EGLDisplay——它封装了所有与本地窗口系统接口的系统依赖。任何使用EGL的应用程序需要做的第一个操作是创建并初始化与本地EGL显示器的连接。这是在两个调用序列中完成的，如示例3-1所示。

Because every windowing system has different semantics, EGL provides a basic  opaque type—the EGLDisplay—that encapsulates all of the system dependencies for  interfacing with the native windowing system. The first operation that any  application using EGL will need to do is create and initialize a connection with  the local EGL display. This is done in a two-call sequence, as shown in Example  3-1.

```c
Example 3-1 Initializing EGL
EGLint  majorVersion;
EGLint  minorVersion;
EGLDisplay  display;
display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
if(display == EGL_NO_DISPLAY)
{
   // Unable to open connection to local windowing system
}
if(!eglInitialize(display, &majorVersion, &minorVersion))
{
   // Unable to initialize EGL. Handle and recover
}
```

要打开与EGL显示服务器的连接，请调用

To open a connection to the EGL display server, call.

<img src="images/image-20210317080356373.png" alt="image-20210317080356373" style="zoom:50%;" />

EGLNativeDisplayType被定义为匹配本机窗口系统的显示类型。例如，在微软视窗系统上，一个活动显示类型将被定义为一个HDC——一个微软视窗设备上下文的句柄。但是，为了便于将代码移动到不同的操作系统和平台，令牌EGL_DEFAULT_DISPLAY被接受，并将返回到默认本机显示的连接，就像我们所做的那样。

EGLNativeDisplayType is defined to match the native window system’s display  type. On Microsoft Windows, for example, an EGLNativeDisplayType would be  defined to be an HDC—a handle to the Microsoft Windows device context. However,  to make it easy to move your code to different operating systems and platforms,  the token EGL_DEFAULT_DISPLAY is accepted and will return a connection to the  default native display, as we did.

如果显示连接不可用，则显示将返回EGL_NO_DISPLAY。此错误表明EGL不可用，您将无法使用OpenGL ES 2.0

If a display connection isn’t available, eglGetDisplay will return  EGL_NO_DISPLAY. This error indicates that EGL isn’t available, and you won’t be  able to use OpenGL ES 2.0。

在我们继续讨论更多的EGL操作之前，我们需要简要描述EGL如何处理并向您的应用程序报告错误。

Before we continue discussing more EGL operation, we need to briefly describe  how EGL processes and reports errors to your application.

## 检查错误

Checking for Errors

EGL的大多数函数成功时返回EGL为真，否则返回EGL为假。然而，EGL不仅仅会告诉你如果通话失败，它还会记录一个错误来指出失败的原因。但是，错误代码不会直接返回给您；您需要显式查询EGL的错误代码，这可以通过调用

Most functions in EGL return EGL_TRUE when successful and EGL_FALSE otherwise.  However, EGL will do more than just tell you if the call failed, it will record  an error to indicate the reason for failure. However, that error code isn’t  returned to you directly; you need to query EGL explicitly for the error code,  which you can do by calling

<img src="images/image-20210317080714968.png" alt="image-20210317080714968" style="zoom:50%;" />、

您可能想知道为什么这是一种谨慎的方法，而不是在调用完成时直接返回错误代码。虽然我们从不鼓励忽略函数返回代码，但允许可选的错误代码恢复可以减少应用程序中被验证为正常工作的冗余代码。您当然应该在开发和调试期间，以及在关键应用程序中的所有时间检查错误，但是一旦您确信您的应用程序按预期工作，您就可以减少错误检查。

You might wonder why this is a prudent approach, as compared to directly  returning the error code when the call completes. Although we never encourage  ignoring function return codes, allowing optional error code recovery reduces  redundant code in applications verified to work properly. You should certainly  check for errors during development and debugging, and all the time in critical  applications, but once you’re convinced your application is working as expected,  you can likely reduce your error checking.

## 初始化EGL

Initializing EGL

一旦您成功地打开了一个连接，EGL需要初始化，这是通过调用

Once you’ve successfully opened a connection, EGL needs to be initialized,  which is done by calling

<img src="images/image-20210317080909770.png" alt="image-20210317080909770" style="zoom:50%;" />

这将初始化EGL的内部数据结构，并返回EGL实现的主要和次要版本号。如果EGL无法初始化，此调用将返回EGL  _假，并将EGL的错误代码设置为:

This initializes EGL’s internal data structures and returns the major and  minor version numbers of the EGL implementation. If EGL is unable to be  initialized, this call will return EGL_FALSE, and set EGL’s error code  to:

- 如果DISPLAY没有指定有效的EGLDisplay，则显示EGL。

  EGL_BAD_DISPLAY if display doesn’t specify a valid EGLDisplay. 

- 如果EGL不能被初始化，则EGL不能被初始化。

  EGL_NOT_INITIALIZED if the EGL cannot be initialized.

## 确定可用的表面配置

Determining the Available Surface Configurations

