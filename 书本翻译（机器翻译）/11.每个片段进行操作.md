# 每个片段进行操作

本章讨论在OpenGL  ES  2.0片段流水线中执行片段着色器后，可以应用于整个帧缓冲区或单个片段的操作。您会记得，片段着色器的输出是片段的颜色和深度值。片段着色器执行后发生的操作会影响像素的可见性和最终颜色:

This chapter discusses the operations that can be applied either to the entire  framebuffer or to individual fragments after the execution of the fragment  shader in the OpenGL ES 2.0 fragment pipeline. As you’ll recall, the output of  the fragment shader is the fragment’s color and depth value. The operations that  occur after fragment shader execution and can affect the visibility and final  color of a pixel are:

- 模板缓冲测试 
- 深度缓冲测试
- 多重采样
- 混合
-  

图11-1显示了片段在到达帧缓冲区的过程中所经历的测试和操作。

The tests and operations that a fragment goes through on its way to the  framebuffer are shown in Figure 11-1.

<img src="images/image-20210327092520173.png" alt="image-20210327092520173" style="zoom:50%;" />



正如你可能已经注意到的，没有一个阶段叫做“多重采样”多重采样是一种抗锯齿技术，它在子片段级别复制操作。我们将在本章后面描述多采样如何影响片段处理。本章最后讨论了从帧缓冲区读取像素和向帧缓冲区写入像素的方法。

As you might have noticed, there isn’t a stage named “multisampling.”  Multisampling is an antialiasing technique that duplicates operations at a  subfragment level. We describe more about how multisampling affects fragment  processing later in the chapter. The chapter concludes with a discussion of  methods for reading pixels from and writing pixels to the framebuffer.

## 缓冲区

OpenGL  ES支持三种类型的缓冲区，每种缓冲区都为帧缓冲区中的每个像素存储不同的数据:

OpenGL ES supports three types of buffers, each of which stores different data  for every pixel in the framebuffer:

- 色彩缓冲区(由正面和背面色彩缓冲区组成)。

  Color buffer (composed of front and back color buffers).

- 深度缓冲。

  Depth buffer.

- 模板缓冲区。

  Stencil buffer.

缓冲区的大小——通常称为“缓冲区深度”(但不要与深度缓冲区混淆)——是由可用于存储单个像素信息的位数来衡量的。例如，颜色缓冲区将有三个组件用于存储红色、绿色和蓝色组件，以及可选的alpha组件存储。颜色缓冲区的深度是其所有组件的位数总和。另一方面，对于深度和模板缓冲区，单个值表示这些缓冲区中像素的位深度。例如，深度缓冲区可能每个像素有16位。缓冲区的总大小是所有组件的位深度之和。常见的帧缓冲区深度包括16位RGB缓冲区，5位用于红色和蓝色，6位用于绿色(人类视觉系统对绿色比对红色或蓝色更敏感)，32位等分用于RGBA缓冲区。

The size of a buffer—commonly referred to as the “depth of the buffer” (but  not to be confused with the depth buffer)—is measured by the number of bits that  are available for storing information for a single pixel. The color buffer, for  example, will have three components for storing the red, green, and blue color  components, and optional storage for the alpha component. The depth of the color  buffer is the sum of the number of bits for all of its components. For the depth  and stencil buffers, on the other hand, a single value represents the bit depth  of a pixel in those buffers. For example, a depth buffer might have 16 bits per  pixel. The overall size of the buffer is the sum of the bit depths of all of the  components. Common framebuffer depths include 16-bit RGB buffers, with five bits  for red and blue, and six bits for green (the human visual system is more  sensitive to green than red or blue), and 32 bits divided equally for an RGBA  buffer.

此外，颜色缓冲区可以是双缓冲的，其中它将包含两个缓冲区:一个显示在输出设备(通常是监视器或液晶显示器)上，称为“前”缓冲区；和另一个对观众隐藏的缓冲区，但是用于构建要显示的下一个图像，并被称为“后”缓冲区。在双缓冲应用程序中，动画是通过绘制到后缓冲区，然后交换前缓冲区和后缓冲区来显示新图像来完成的。缓冲区的这种交换通常与显示设备的刷新周期同步，这将给出连续平滑动画的幻觉。回想一下，双缓冲在第三章“EGL导论”中讨论过

Additionally, the color buffer may be double buffered, where it will contain  two buffers: one that is displayed on the output device (usually a monitor or  LCD display) named the “front” buffer; and another buffer that is hidden from  the viewer, but used for constructing the next image to be displayed, and called  the “back” buffer. In double-buffered applications, animation is accomplished by  drawing into the back buffer, and then swapping the front and back buffers to  display the new image. This swapping of buffers is usually synchronized with the  refresh cycle of the display device, which will give the illusion of a  continuously smooth animation. Recall that double buffering was discussed in  Chapter 3, “An Introduction to EGL.”

虽然每个EGL配置都有一个颜色缓冲区，但深度和模板缓冲区是可选的。然而，每个EGL实现必须提供至少一个包含所有三个缓冲区的配置，深度缓冲区至少为16位，模板缓冲区至少为8位。

Although every EGL configuration will have a color buffer, the depth and  stencil buffers are optional. However, every EGL implementation must provide at  least one configuration that contains all three of the buffers, with the depth  buffer being at least 16 bits deep, and at least eight bits for the stencil  buffer.

## 请求附加缓冲区

Requesting Additional Buffers

要在颜色缓冲区中包含深度或模板缓冲区，您需要在指定EGL配置的属性时请求它们。您可能还记得第3章，您向EGL传递了一组属性-值对，这些属性-值对指定了应用程序需要的渲染表面的类型。要在颜色缓冲区之外包含深度缓冲区，您可以在属性列表中指定EGL  _深度_大小以及所需的位深度。同样，您可以添加EGL _模板_大小以及所需的位数来获得模板缓冲区。

To include a depth or stencil buffer along with your color buffer, you need to  request them when you specify the attributes for your EGL configuration. As you  might recall from Chapter 3, you pass a set of attribute–value pairs into the  EGL that specify the type of rendering surface your application needs. To  include a depth buffer in addition to the color buffer, you would specify  EGL_DEPTH_SIZE in the list of attributes with the desired bit depth you need.  Likewise, you would add EGL_STENCIL_SIZE along with the number of required bits  to obtain a stencil buffer.

我们的便利库esUtil简化了这些操作，它只允许您说您想要这些缓冲区和一个颜色缓冲区，并且它负责其余的工作(请求最大大小的缓冲区)。当使用我们的库时，您可以在调用esCreateWindow时添加(通过按位“或”运算)ES_WINDOW_DEPTH和ES  _ WINDOW _ DEPTH。比如，

Our convenience library, esUtil, simplifies those operations by merely  allowing you to say that you’d like those buffers along with a color buffer, and  it takes care of the rest of the work (requesting a maximally sized buffer).  When using our library, you would add (by means of a bitwise-or operation)  ES_WINDOW_DEPTH and ES_WINDOW_STENCIL in your call to esCreateWindow. For  example,

```c
esCreateWindow(&esContext, "Application Name",
               window_width, window_height,
               ES_WINDOW_RGB | ES_WINDOW_DEPTH | ES_WINDOW_STENCIL);
```

## 清除缓冲区

Clearing Buffers

OpenGL  ES是一个交互式渲染系统，假设在每一帧的开始，您希望将所有缓冲区初始化为默认值。通过调用glClear函数来清除缓冲区，该函数使用一个位掩码来表示应该清除到其指定清除值的各种缓冲区。

OpenGL ES is an interactive rendering system, and assumes that at the start of  each frame, you’ll want to initialize all of the buffers to their default value.  Buffers are cleared by calling the glClear function, which takes a bitmask  representing the various buffers that should be cleared to their specified clear  values.

<img src="images/image-20210327093118818.png" alt="image-20210327093118818" style="zoom:50%;" />



您既不需要清除每个缓冲区，也不需要同时清除所有缓冲区，但是您可以通过每帧只调用一次glClear并同时清除所有缓冲区来获得最佳性能。

You’re neither required to clear every buffer, nor clear them all at the same  time, but you might obtain the best performance by only calling glClear once per  frame with all the buffers you want simultaneously cleared.

每个缓冲区都有一个默认值，在您请求清除该缓冲区时使用。对于每个缓冲区，您可以使用此处显示的函数指定所需的清除值。

Each buffer has a default value that’s used when you request that buffer be  cleared. For each buffer, you can specify your desired clear value using the  functions shown here.

<img src="images/image-20210327093209472.png" alt="image-20210327093209472" style="zoom:50%;" />

<img src="images/image-20210327093226321.png" alt="image-20210327093226321" style="zoom:50%;" />

<img src="images/image-20210327093240946.png" alt="image-20210327093240946" style="zoom:50%;" />

## 使用掩码控制对帧缓冲区的写入

Using Masks to Control Writing to Framebuffers

您还可以通过指定缓冲区写掩码来控制哪些缓冲区或组件(在颜色缓冲区的情况下)是可写的。在像素值写入缓冲区之前，缓冲区的掩码用于验证缓冲区是否可写。

You can also control which buffers, or components, in the case of the color  buffer, are writable by specifying a buffer write mask. Before a pixel’s value  is written into a buffer, the buffer’s mask is used to verify that the buffer is  writable.

