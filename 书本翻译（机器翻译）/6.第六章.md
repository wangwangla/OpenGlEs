# 顶点属性、顶点数组和缓冲对象

Vertex Attributes, Vertex Arrays, and Buffer Objects

本章描述了在OpenGL  ES  2.0中如何指定顶点属性和数据。我们讨论什么是顶点属性，如何指定它们和它们支持的数据格式，以及如何将顶点属性索引绑定到顶点着色器中使用的适当顶点属性名称。看完这一章，你应该很好的掌握了什么是顶点属性，以及如何在OpenGL  ES 2.0中用顶点属性绘制图元。

This chapter describes how vertex attributes and data are specified in OpenGL  ES 2.0. We discuss what vertex attributes are, how to specify them and their  supported data formats, and how to bind vertex attribute indices to the  appropriate vertex attribute names used in a vertex shader. After reading this  chapter, you should have a good grasp of what vertex attributes are and how to  draw primitives with vertex attributes in OpenGL ES 2.0.

顶点数据，也称为顶点属性，指定每个顶点的数据。可以为每个顶点指定每个顶点的数据，或者可以为所有顶点使用一个常数值。例如，如果你想画一个有纯色的三角形(为了这个例子，假设颜色是黑色，如图6-1所示)，你可以指定一个常量值，该值将被三角形的所有三个顶点使用。然而，组成三角形的三个顶点的位置不会相同，因此我们需要指定一个存储三个位置值的顶点数组。

顶点数据，可以使用一个顶点数据，或者是每个顶点都指定一个数据。

Vertex data, also referred to as vertex attributes, specify per-vertex data.  This per-vertex data can be specified for each vertex or a constant value can be  used for all vertices. For example, if you want to draw a triangle that has a  solid color (for the sake of this example say the color is black as shown in  Figure 6-1), you would specify a constant value that will be used by all three  vertices of the triangle. However, the position of the three vertices that make  up the triangle will not be the same and therefore we will need to specify a  vertex array that stores three position values.

在OpenGL  ES 1.1中，顶点属性有预定义的名称，如位置、法线、颜色和纹理坐标。这是可以接受的，因为OpenGL ES  1.1实现的固定函数管道只需要这些预定义的顶点属性。通过可编程管道，开发人员需要能够指定他们自己在顶点着色器中使用的顶点属性名称。因此，支持用户定义的(即通用的)顶点属性成为OpenGL  ES 2.0的一项要求。如果应用编程接口支持通用顶点属性，则不再需要支持预定义的顶点属性名称，因为它们可以由应用程序映射到通用顶点属性之一。

1.1有预定义的名称，2.0可以自定义名称

In OpenGL ES 1.1, vertex attributes had predefined names such as position,  normal, color, and texture coordinates. This was acceptable because the fixed  function pipeline implemented by OpenGL ES 1.1 only required these predefined  vertex attributes. With a programmable pipeline, developers need to be able to  specify their own vertex attribute names used in vertex shaders. Support for  user-defined (i.e., generic) vertex attributes therefore became a requirement  for OpenGL ES 2.0. If generic vertex attributes are supported by the API then  there is no longer a need to support predefined vertex attribute names because  they can be mapped by the application to one of the generic vertex  attributes.

## 指定顶点属性数据

Specifying Vertex Attribute Data

如前所述，OpenGL  ES 2.0只支持通用顶点属性。属性数据可以使用顶点数组为每个顶点指定，也可以是用于图元所有顶点的常数值。

顶点可以使用数组为每个顶点使用，**也可以用于图元顶点的常数值。

As mentioned before, only generic vertex attributes are supported by OpenGL ES  2.0. The attribute data can be specified for each vertex using a vertex array or  it can be a constant value that is used for all vertices of a  primitive.

所有OpenGL  ES  2.0实现必须支持最少八个顶点属性。应用程序可以查询特定实现支持的顶点属性的确切数量，该数量可能大于8。下面的代码描述了应用程序如何查询一个实现实际支持的顶点属性的数量。

查询open el es支持多少中属性。

All OpenGL ES 2.0 implementations must support a minimum of eight vertex  attributes. An application can query the exact number of vertex attributes that  are supported by a particular implementation, which might be greater than eight.  The following code describes how an application can query the number of vertex  attributes an implementation actually supports.

```java
GLint maxVertexAttribs;   // n will be >= 8
glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &maxVertexAttribs);
```

## 恒定顶点属性

Constant Vertex Attribute

常数顶点属性对于图元的所有顶点都是相同的，因此只需要为图元的所有顶点指定一个值。

A constant vertex attribute is the same for all vertices of a primitive, and  therefore only one value needs to be specified for all the vertices of a  primitive.

使用以下任一函数指定恒定的顶点属性值:

A constant vertex attribute value is specified using any of the following  functions:

```java
void glVertexAttrib1f(GLuint index, GLfloat x);
void glVertexAttrib2f(GLuint index, GLfloat x, GLfloat y);
void glVertexAttrib3f(GLuint index, GLfloat x, GLfloat y, GLfloat z);
void glVertexAttrib4f(GLuint index, GLfloat x, GLfloat y, GLfloat z,
                      GLfloat w);
void glVertexAttrib1fv(GLuint index, const GLfloat *values);
void glVertexAttrib2fv(GLuint index, const GLfloat *values);
void glVertexAttrib3fv(GLuint index, const GLfloat *values);
void glVertexAttrib4fv(GLuint index, const GLfloat *values);
```

glVertexAttrib*命令用于加载由索引指定的通用顶点属性。glVertexAttrib1f和glVertexAttrib1fv将(x，0.0，0.0，1.0)加载到通用顶点属性中。glVertexAttrib2f和glVertexAttrib2fv将(x，y，0.0，1.0)加载到通用顶点属性中。glVertexAttrib3f和glVertexAttrib3fv将(x，y，z，1.0)载入通用顶点属性。glVertexAttrib4f和glVertexAttrib4fv将(x，y，z，w)加载到通用顶点属性中。

The glVertexAttrib* commands are used to load the generic vertex attribute  specified by index. glVertexAttrib1f and glVertexAttrib1fv load (x, 0.0, 0.0,  1.0) into the generic vertex attribute. glVertexAttrib2f and glVertexAttrib2fv  load (x, y, 0.0, 1.0) into the generic vertex attribute. glVertexAttrib3f and  glVertexAttrib3fv load (x, y, z, 1.0) into the generic vertex attribute.  glVertexAttrib4f and glVertexAttrib4fv load (x, y, z, w) into the generic vertex  attribute.

出现了一个问题:OpenGL和更高版本支持将常量顶点属性数据指定为字节、无符号字节、短、无符号短、int、无符号int、float和double的函数。OpenGL  ES 2.0为什么只支持浮点数变体？这是因为不变的顶点属性没有被经常使用。因为它们的使用很少，并且因为它们很可能在内部存储为单精度浮点值，所以ES  2.0只支持浮点变量。

A question arises: OpenGL version 2.0 and higher supports functions that  specify the constant vertex attribute data as byte, unsigned byte, short,  unsigned short, int, unsigned int, float, and double. Why does OpenGL ES 2.0  only support the float variant? The reason for this is that constant vertex  attributes are not used that frequently. Because their use is infrequent, and  because they will most likely be stored as single precision floating-point  values internally, ES 2.0 only supports the float variant.

## 顶点数组

Vertex Arrays

顶点数组指定每个顶点的属性数据，是存储在应用程序地址空间(OpenGL  ES称之为客户端空间)的缓冲区。它们为指定顶点属性数据提供了一种高效灵活的方法。顶点数组是使用glVertexAttribPointer函数指定的。

Vertex arrays specify attribute data per vertex and are buffers stored in the  application’s address space (what OpenGL ES calls the client space). They  provide an efficient and flexible way for specifying vertex attribute data.  Vertex arrays are specified using the glVertexAttribPointer function.

<img src="images/image-20210321083315186.png" alt="image-20210321083315186" style="zoom:50%;" />

<img src="images/image-20210321083619598.png" alt="image-20210321083619598" style="zoom:50%;" />

我们给出几个例子来说明如何用glVertexAttribPointer指定顶点属性。分配和存储顶点属性数据的常用方法有:

We present a few examples that illustrate how to specify vertex attributes  with glVertexAttribPointer. The commonly used methods for allocating and storing  vertex attribute data are:

- 将顶点属性一起存储在一个缓冲区中。这种存储顶点属性的方法称为结构数组。该结构表示一个顶点的所有属性，每个顶点有一个这些属性的数组。

  Store vertex attributes together in a single buffer. This method of storing  vertex attributes is called an array of structures. The structure represents all  attributes of a vertex and we have an array of these attributes per  vertex.

- 将每个顶点属性存储在单独的缓冲区中。这种存储顶点属性的方法称为数组结构。

  Store each vertex attribute in a separate buffer. This method of storing  vertex attributes is called structure of arrays.

假设每个顶点有四个顶点属性——位置、法线和两个纹理坐标——并且这些属性一起存储在一个为所有顶点分配的缓冲区中。顶点的属性是指定为三个浮动的向量(x，y，z)，顶点法线也指定为三个浮动的向量，每个纹理坐标指定为两个浮动的向量。图6-2给出了这个缓冲区的内存布局。

Let us say that each vertex has four vertex attributes—position, normal, and  two texture coordinates—and that these attributes are stored together in one  buffer that is allocated for all vertices.The vertex position attribute is specified as a vector of three floats (x, y, z), the vertex normal is also  specified as a vector of three floats, and each texture coordinate is specified  as a vector of two floats. Figure 6-2 gives the memory layout of this  buffer.

<img src="images/image-20210321195605912.png" alt="image-20210321195605912" style="zoom:50%;" />



```java
Example 6-1 describes how these four vertex attributes are specified with 
glVertexAttribPointer.
Example 6-1 Array of Structures
#define VERTEX_POS_SIZE           3   // x, y and z
#define VERTEX_NORMAL_SIZE        3   // x, y and z
#define VERTEX_TEXCOORD0_SIZE     2   // s and t
#define VERTEX_TEXCOORD1_SIZE     2   // s and t
#define VERTEX_POS_INDX           0
#define VERTEX_NORMAL_INDX        1
#define VERTEX_TEXCOORD0_INDX     2
#define VERTEX_TEXCOORD1_INDX     3
// the following 4 defines are used to determine location of various
// attributes if vertex data is are stored as an array of structures
#define VERTEX_POS_OFFSET         0
#define VERTEX_NORMAL_OFFSET      3
#define VERTEX_TEXCOORD0_OFFSET   6
#define VERTEX_TEXCOORD1_OFFSET   8
#define VERTEX_ATTRIB_SIZE   VERTEX_POS_SIZE + \
                             VERTEX_NORMAL_SIZE + \
                             VERTEX_TEXCOORD0_SIZE + \
                             VERTEX_TEXCOORD1_SIZE
float *p  = malloc(numVertices * VERTEX_ATTRIB_SIZE 
                   * sizeof(float));
// position is vertex attribute 0
glVertexAttribPointer(VERTEX_POS_INDX, VERTEX_POS_SIZE, 
                      GL_FLOAT, GL_FALSE, 
                      VERTEX_ATTRIB_SIZE * sizeof(float),
                      p);
// normal is vertex attribute 1
glVertexAttribPointer(VERTEX_NORMAL_INDX, VERTEX_NORMAL_SIZE, 
                      GL_FLOAT, GL_FALSE, 
                      VERTEX_ATTRIB_SIZE * sizeof(float), 
                      (p +  VERTEX_NORMAL_OFFSET));
// texture coordinate 0 is vertex attribute 2
glVertexAttribPointer(VERTEX_TEXCOORD0_INDX, VERTEX_TEXCOORD0_SIZE,
                      GL_FLOAT, GL_FALSE, 
                      VERTEX_ATTRIB_SIZE * sizeof(float), 
                      (p +  VERTEX_TEXCOORD0_OFFSET));
// texture coordinate 1 is vertex attribute 3
glVertexAttribPointer(VERTEX_TEXCOORD1_INDX, VERTEX_TEXCOORD1_SIZE, 
                      GL_FLOAT, GL_FALSE, 
                      VERTEX_ATTRIB_SIZE * sizeof(float), 
                      (p + VERTEX_TEXCOORD1_OFFSET));
```

在接下来的示例6-2中，位置、法线和纹理坐标0和1存储在单独的缓冲区中。

In Example 6-2 that follows, position, normal, and texture coordinate 0 and 1  are stored in separate buffers.

```java
Example 6-2 Structure of Arrays
float *position  = malloc(numVertices * VERTEX_POS_SIZE * 
                          sizeof(float));
float *normal    = malloc(numVertices * VERTEX_NORMAL_SIZE * 
                          sizeof(float));
float *texcoord0 = malloc(numVertices * VERTEX_TEXCOORD0_SIZE * 
                          sizeof(float));
float *texcoord1 = malloc(numVertices * VERTEX_TEXCOORD1_SIZE * 
                          sizeof(float));
// position is vertex attribute 0
glVertexAttribPointer(VERTEX_POS_INDX, VERTEX_POS_SIZE, 
                      GL_FLOAT, GL_FALSE,
                      VERTEX_POS_SIZE * sizeof(float), position);
// normal is vertex attribute 1
glVertexAttribPointer(VERTEX_NORMAL_INDX, VERTEX_NORMAL_SIZE, 
                      GL_FLOAT, GL_FALSE, 
                      VERTEX_NORMAL_SIZE * sizeof(float), normal);
// texture coordinate 0 is vertex attribute 2
glVertexAttribPointer(VERTEX_TEXCOORD0_INDX, VERTEX_TEXCOORD0_SIZE,
                      GL_FLOAT, GL_FALSE, VERTEX_TEXCOORD0_SIZE * 
                      sizeof(float), texcoord0);
// texture coordinate 1 is vertex attribute 3
glVertexAttribPointer(VERTEX_TEXCOORD1_INDX, VERTEX_TEXCOORD1_SIZE, 
                      GL_FLOAT, GL_FALSE, 
                      VERTEX_TEXCOORD1_SIZE * sizeof(float),
                      texcoord1);
```



**性能提示**

Performance Hints

- 如何存储顶点的不同属性

  How to store different attributes of a vertex

  我们描述了存储顶点属性的两种最常见的方式——**结构数组和数组结构**。要问的问题是哪种分配方法对OpenGL  ES  2.0硬件实现最有效。答案是一系列的结构。原因是每个顶点的属性数据可以按顺序读取，因此很可能会产生高效的内存访问模式。使用结构数组的一个缺点是当应用程序想要修改特定的属性时。**如果顶点属性数据的子集需要修改(例如纹理坐标)，这将导致顶点缓冲区的逐行更新。当顶点缓冲区作为缓冲区对象提供时，需要重新加载整个顶点属性缓冲区**。通过将本质上是动态的顶点属性存储在单独的缓冲区中，可以避免这种低效。

  - 结构数组：将所有的数据存储在一个数组里面
  - 数组结构：将属性值分开存储。

  优缺点：结构数组很适合内存的读取方式，但是如果发生修改，就需要修改属性的子集，就需要逐行更新

  We described the two most common ways of storing vertex attributes— array of  structures and structure of arrays. The question to ask is which allocation  method would be the most efficient for OpenGL ES 2.0 hardware implementations.  The answer is array of structures. The reason is that the attribute data for  each vertex can be read in sequential fashion and so will most likely result in  an efficient memory access pattern. A disadvantage of using array of structures  is when an application wants to modify specific attributes. If a subset of  vertex attribute data needs to be modified (e.g., texture coordinates), this  will result in strided updates to the vertex buffer. When vertex buffer is  supplied as a buffer object, the entire vertex attribute buffer will need to be  reloaded. One can avoid this inefficiency by storing vertex attributes that are  dynamic in nature in a separate buffer.

- 顶点属性使用哪种数据格式

  Which data format to use for vertex attributes

  glVertexAttribPointer中类型参数指定的顶点属性数据格式不仅会影响顶点属性数据的图形内存存储要求，还会影响整体性能，这是渲染帧所需内存带宽的函数。数据占用空间越小，所需的内存带宽就越低。我们的建议是，应用程序应该尽可能使用GL_HALF_FLOAT_OES。纹理坐标、法线、副法线、切向量等等都是很好的候选对象，可以使用GL_HALF_FLOAT_OES为每个组件存储。颜色可以存储为每个顶点颜色有四个分量的GL_UNSIGNED_BYTE。我们也推荐GL_HALF_FLOAT_OES用于顶点位置，但是要认识到这在相当多的情况下是不可能的。在这种情况下，顶点位置可以存储为浮点型或固定型。

  The vertex attribute data format specified by the type argument in  glVertexAttribPointer cannot only impact the graphics memory storage  requirements for vertex attribute data, but can also impact the overall  performance, which is a function of memory bandwidth required to render the  frame(s). The smaller the data footprint, the lower the memory bandwidth  required. Our recommendation is that applications should use GL_HALF_FLOAT_OES  wherever possible. Texture coordinates, normals, binormals, tangent vectors, and  so on are good candidates to be stored using GL_HALF_FLOAT_OES for each  component. Color could be stored as GL_UNSIGNED_BYTE with four components per  vertex color. We also recommend GL_HALF_FLOAT_OES for vertex position, but  recognize that this might not be possible for quite a few cases. For such cases,  the vertex position could be stored as GL_FLOAT or GL_FIXED.

- glVertexAttribPointer中的规范化标志是如何工作的

  How the Normalized Flag in glVertexAttribPointer Works

  顶点属性在顶点着色器中使用之前，在内部存储为单精度浮点数。如果数据类型指示顶点属性不是浮点数，则顶点属性在顶点着色器中使用之前将被转换为单精度浮点数。规范化标志控制非浮动顶点属性数据到单精度浮点值的转换。如果规范化标志为假，顶点数据将直接转换为浮点值。这类似于将非浮点类型的变量转换为浮点类型。下面的代码给出了一个例子。

  Vertex attributes are internally stored as a single precision floating-point  number before they get used in a vertex shader. If the data type indicates that  the vertex attribute is not a float, then the vertex attribute will be converted  to a single precision floating-point number before it gets used in a vertex  shader. The normalized flag controls the conversion of the nonfloat vertex  attribute data to a single precision floating-point value. If the normalized  flag is false, the vertex data is converted directly to a floating-point value.  This would be similar to casting the variable that is not a float type to float.  The following code gives an example.

  ```java
  GLfloat   f;
  GLbyte    b;
  f = (GLfloat)b;  // f represents values in the range [-128.0, 127.0]
  ```

  如果规范化标志为真，如果数据类型为GL_BYTE、GL_SHORT或GL_FIXED，则顶点数据映射到[–1.0，1.0]范围，如果数据类型为GL_UNSIGNED_BYTE或GL_UNSIGNED_SHORT，则映射到[0.0，1.0]范围。

  If the normalized flag is true, the vertex data is mapped to the [–1.0, 1.0]  range if the data type is GL_BYTE, GL_SHORT or GL_FIXED or to the [0.0, 1.0]  range if the data type is GL_UNSIGNED_BYTE or GL_UNSIGNED_SHORT.

  <img src="images/image-20210321201427806.png" alt="image-20210321201427806" style="zoom:50%;" />

  

## 在恒定顶点属性或顶点数组之间进行选择

Selecting Between a Constant Vertex Attribute or a Vertex Array.

应用程序可以启用它是否希望OpenGL  ES使用常数数据或来自顶点数组的数据。图6-3描述了这在OpenGL ES 2.0中是如何工作的。

The application can enable whether it wants OpenGL ES to use the constant data  or data from vertex array. Figure 6-3 describes how this works in OpenGL ES  2.0.

<img src="images/image-20210321201607808.png" alt="image-20210321201607808" style="zoom:50%;" />

命令glEnableVertexAttribArray和glDisableVertexAttribArray用于启用和禁用通用顶点属性数组。如果对一般属性索引禁用顶点属性数组，将使用为该索引指定的恒定顶点属性数据。

The commands glEnableVertexAttribArray and glDisableVertexAttribArray are used  to enable and disable a generic vertex attribute array. If the vertex attribute  array is disabled for a generic attribute index, the constant vertex attribute  data specified for that index will be used.

<img src="images/image-20210321201720153.png" alt="image-20210321201720153" style="zoom:50%;" />



```c
Example 6-3 describes how to draw a triangle where one of the vertex 
attributes is constant and the other is specified using a vertex array. 
Example 6-3 Using Constant and Vertex Array Attributes
GLbyte vertexShaderSrc[] =  
      "attribute vec4 a_position;    \n"
      "attribute vec4 a_color;       \n"
      "varying vec4   v_color;       \n"
      "void main()                   \n"
      "{                             \n"
      "    v_color = a_color;        \n"
      "    gl_Position = a_position; \n"
      "}";
GLbyte fragmentShaderSrc[] =
      "varying vec4 v_color;         \n"
      "void main()                   \n"
    "{                             \n"
      "    gl_FragColor = v_color;   \n"
      "}";
GLfloat   color[4] = { 1.0f, 0.0f, 0.0f, 1.0f };
GLfloat   vertexPos[3 * 3];  // 3 vertices, with (x,y,z) per-vertex
GLuint    shaderObject[2];
GLuint    programObject;
shaderObject[0] = LoadShader(vertexShaderSrc, GL_VERTEX_SHADER);
shaderObject[1] = LoadShader(fragmentShaderSrc, GL_FRAGMENT_SHADER);
programObject = glCreateProgram();
glAttachShader(programObject, shaderObject[0]);
glAttachShader(programObject, shaderObject[1]);
//------------------------------------
glVertexAttrib4fv(0, color);
glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 0, vertexPos);
glEnableVertexAttribArray(1);
//-------------------------------------
glBindAttribLocation(programObject, 0, "a_color");
glBindAttribLocation(programObject, 1, "a_position");
glLinkProgram(programObject);
glUseProgram(programObject);
glDrawArrays(GL_TRIANGLES, 0, 3);
```

代码示例中使用的顶点属性颜色是常数值，而顶点操作系统属性是使用顶点数组指定的。绘制的三角形的所有顶点的颜色值都是相同的，而绘制的三角形的顶点的顶点属性可能不同。

The vertex attribute color used in the code example is a constant value  whereas the vertexPos attribute is specified using a vertex array. The value of  color will be the same for all vertices of the triangle(s) drawn whereas the  vertexPos attribute could vary for vertices of the triangle(s) drawn.

## 在顶点着色器中声明顶点属性变量

Declaring Vertex Attribute Variables in a Vertex Shader

我们已经了解了什么是顶点属性，以及如何在OpenGL  ES中指定顶点属性。我们现在讨论如何在顶点着色器中声明顶点属性变量。

We have looked at what a vertex attribute is, and how to specify vertex  attributes in OpenGL ES. We now discuss how to declare vertex attribute  variables in a vertex shader.                                      

在顶点着色器中，使用属性限定符将变量声明为顶点属性。属性限定符只能在顶点着色器中使用。如果在片段着色器中使用了属性限定符，则在编译片段着色器时会导致错误。

In a vertex shader, a variable is declared as a vertex attribute by using the  attribute qualifier. The attribute qualifier can only be used in a vertex  shader. If the attribute qualifier is used in a fragment shader, it should  result in an error when the fragment shader is compiled.

这里给出了几个顶点属性声明的例子。

A few example declarations of vertex attributes are given here.

```c
attribute vec4   a_position;
attribute vec2   a_texcoord;
attribute vec3   a_normal;
```

**属性限定符只能用于数据类型**float、vec2、vec3、vec4、mat2、mat3和mat4。属性变量不能声明为数组或结构。以下示例声明The attribute qualifier can be used only with the data types float, vec2,  vec3, vec4, mat2, mat3, and mat4. Attribute variables cannot be declared as  arrays or structures. The following example declarations.

```c
attribute foo_t  a_A;   // foo_t is a structure
attribute vec4   a_B[10]; 
```

OpenGL  ES 2.0实现支持GL _ MAX _ VENTURE _ ATTRIBS vec  4顶点属性。声明为float或vec2或vec3的顶点属性将被视为一个vec4属性。声明为mat2、mat3或mat4的顶点属性将分别计为两个、三个或四个vec4属性。不同于由编译器自动打包的统一变量和可变变量，属性不会被打包。每个组件由实现内部存储为32位单精度浮点值。当声明尺寸小于vec4的顶点属性时，请仔细考虑，因为**可用顶点属性的最大数量是有限的资源**。最好将它们打包成一个vec4属性，而不是在顶点着色器中将它们声明为单独的顶点属性。

An OpenGL ES 2.0 implementation supports GL_MAX_VERTEX_ATTRIBS vec4 vertex  attributes. A vertex attribute that is declared as a float or vec2 or vec3 will  count as one vec4 attribute. Vertex attributes declared as mat2, mat3, or mat4  will count as two, three, or four vec4 attributes, respectively. Unlike uniform  and varying variables, which get packed automatically by the compiler,  attributes do not get packed. Each component is stored internally by the  implementation as a 32-bit single precision floating-point value. Please  consider carefully when declaring vertex attributes with sizes less than vec4,  as the maximum number of vertex attributes available is a limited resource. It  might be better to pack them together into one vec4 attribute instead of  declaring them as individual vertex attributes in the vertex shader.

在顶点着色器中声明为顶点属性的变量是只读变量，不能修改。下面的代码应该会导致编译错误。

Variables declared as vertex attributes in a vertex shader are read-only  variables and cannot be modified. The following code should cause a compilation  error.

```c
attribute vec4   a_pos;
uniform   vec4   u_v;
void main()
{
   a_pos = u_v; <--- cannot assign to a_pos as it is read-only
}
```

**补充，可以理解为常量**final

一个属性可以在顶点着色器中声明，但是如果它没有被使用，那么它就不被认为是活动的，并且不计算在内。如果顶点着色器中使用的属性数量大于GL_MAX_VERTEX_ATTRIBS，顶点着色器将无法链接。

An attribute can be declared inside a vertex shader but if it is not used then  it is not considered active and does not count against the limit. If the number  of attributes used in a vertex shader is greater than GL_MAX_VERTEX_ATTRIBS, the  vertex shader will fail to link.

一旦一个程序被成功链接，我们需要找出附加到它的顶点着色器所使用的活动顶点属性的数量

Once a program has been successfully linked, we need to find out the number of  active vertex attributes used by the vertex shader attached to this program,wo followers line of code destribes how to get the number of actives vertex attributes.

```java
glGetProgramiv(progam, GL_ACTIVE_ATTRIBUTES, &numActiveAttribs);
```

glGetProgamiv的详细描述在第4章“着色器和程序”中给出

A detailed description of glGetProgamiv is given in Chapter 4, “Shaders and  Programs.”

程序使用的活动顶点属性列表及其数据类型可以使用glGetActiveAttrib命令进行查询。

The list of active vertex attributes used by a program and their data types  can be queried using the glGetActiveAttrib command.

<img src="images/image-20210321203447117.png" alt="image-20210321203447117" style="zoom:50%;" />

```c
void GlGetActiveAttribb(Gluint program，GLuint index，GLsizei bufsize，GLsizei *length，GLint * size，GLenum *type，GLchar *name)
```

- 以前成功链接的程序对象的名称索引指定

  name of a program object that was successfully linked previously index .

- 指定要查询的顶点属性，其值介于0…GL  _ ACTIVE _ ATTRIBUTES–1之间。GL_ACTIVE_ATTRIBUTES的值由glGetProgramiv确定

  specifies the vertex attribute to query and will be a value between 0 …  GL_ACTIVE_ATTRIBUTES – 1. The value of GL_ACTIVE_ATTRIBUTES is determined with  glGetProgramiv

- 指定可以写入名称的最大字符数，包括空终止符

  specifies the maximum number of characters that may be written into name,  including the null terminator

- 如果长度不为空，则返回写入名称的字符数，不包括空终止符

  returns the number of characters written into name excluding the null  terminator, if length is not NULL

- 返回属性的类型。有效值包括:

  returns the type of the attribute. Valid values are:

  ```java
  GL_FLOAT
  GL_FLOAT_VEC2
  GL_FLOAT_VEC3
  GL_FLOAT_VEC4
  GL_FLOAT_MAT2
  GL_FLOAT_MAT3
  GL_FLOAT_MAT4
  ```

- 返回属性的大小。这是以类型返回的类型为单位指定的。如果变量不是数组，大小将始终为1。如果变量是一个数组，那么size返回数组的大小

  returns the size of the attribute. This is specified in units of the type  returned by type. If the variable is not an array, size will always be 1. If the  variable is an array, then size returns the size of the array

- 顶点着色器中声明的属性变量的名称

  name of the attribute variable as declared in the vertex shader

glGetActiveAttrib调用提供了有关索引所选属性的信息。如上所述，索引必须是介于0和GL  _ ACTIVE _  ATTRIBUTES–1之间的值。GL_ACTIVE_ATTRIBUTES的值是使用glGetProgramiv查询的。索引0选择第一个活动属性，索引GL _  ACTIVE _ ATTRIBUTES–1选择最后一个顶点属性。

The glGetActiveAttrib call provides information about the attribute selected  by index. As described above, index must be a value between 0 and  GL_ACTIVE_ATTRIBUTES – 1. The value of GL_ACTIVE_ATTRIBUTES is queried using  glGetProgramiv. An index of 0 selects the first active attributes and an index  of GL_ACTIVE_ATTRIBUTES – 1 selects the last vertex attribute.

## 在顶点着色器中将顶点属性绑定到属性变量

Binding Vertex Attributes to Attribute Variables in a Vertex Shader

我们讨论了在顶点着色器中，顶点属性变量由属性限定符指定，活动属性的数量可以使用glGetProgamiv查询，程序中的活动属性列表可以使用GlGetActiveAttribute查询。我们还描述了范围从0到(GL  _ MAX _ VERTEX _  ATTRIBS–1)的通用属性索引用于启用通用顶点属性，并使用glVertexAttrib*和glVertexAttribPointer命令指定常数或每个顶点(即顶点数组)的值。现在我们描述如何将这个通用属性索引映射到顶点着色器中声明的适当属性变量。该映射将允许适当的顶点数据被读入顶点着色器中正确的顶点属性变量。

We discussed that in a vertex shader, vertex attribute variables are specified  by the attribute qualifier, the number of active attributes can be queried using  glGetProgamiv and the list of active attributes in a program can be queried  using glGetActiveAttrib. We also described that generic attribute indices that  range from 0 to (GL_MAX_VERTEX_ATTRIBS – 1) are used to enable a generic vertex  attribute and specify a constant or per-vertex (i.e., vertex array) value using  the glVertexAttrib* and glVertexAttribPointer commands. Now we describe how to  map this generic attribute index to the appropriate attribute variable declared  in the vertex shader. This mapping will allow appropriate vertex data to be read  into the correct vertex attribute variable in the vertex shader.

图6-4描述了如何在顶点着色器中指定通用顶点属性并将其绑定到属性名。

Figure 6-4 describes how generic vertex attributes are specified and bound to  attribute names in a vertex shader.

OpenGL  ES 2.0有两种方法可以将通用顶点属性索引映射到顶点着色器中的属性变量名。这些方法可以分类如下:

There are two approaches that OpenGL ES 2.0 enables to map a generic vertex  attribute index to an attribute variable name in the vertex shader. These  approaches can be categorized as follows:

- OpenGL  ES 2.0将把通用顶点属性索引绑定到属性名上。

  OpenGL ES 2.0 will bind the generic vertex attribute index to the attribute  name.

- 应用程序可以将顶点属性索引绑定到属性名。

  The application can bind the vertex attribute index to an attribute  name.

**通用属性绑定   顶点属性绑定**

glBindAttribLocation命令可用于将通用顶点属性索引绑定到顶点着色器中的属性变量。该绑定在程序下次链接时生效。它不会更改当前链接程序使用的绑定。

The glBindAttribLocation command can be used to bind a generic vertex  attribute index to an attribute variable in a vertex shader. This binding takes  effect when the program is linked the next time. It does not change the bindings  used by the currently linked program.

<img src="images/image-20210321205356367.png" alt="image-20210321205356367" style="zoom:50%;" />

<img src="images/image-20210321205408321.png" alt="image-20210321205408321" style="zoom:50%;" />

<img src="images/image-20210321205447865.png" alt="image-20210321205447865" style="zoom:50%;" />

如果名称以前绑定过，则其分配的绑定将替换为索引。甚至在顶点着色器附加到程序对象之前，就可以调用glBindAttribLocation。这意味着这个调用可以用来绑定任何属性名。附加到程序对象的顶点着色器中不存在或不活动的属性名将被忽略。

If name was bound previously, its assigned binding is replaced with an index.  glBindAttribLocation can be called even before a vertex shader is attached to a  program object. This means that this call can be used to bind any attribute  name. Attribute names that do not exist or are not active in a vertex shader  attached to the program object are ignored.

另一个选项是让OpenGL  ES 2.0将属性变量名绑定到一个通用的顶点属性索引。该绑定在程序链接时执行。在链接阶段，OpenGL ES 2.0实现对每个属性变量执行以下操作:

The other option is to let OpenGL ES 2.0 bind the attribute variable name to a  generic vertex attribute index. This binding is performed when the program is  linked. In the linking phase, the OpenGL ES 2.0 implementation performs the  following operation for each attribute variable:

对于每个属性变量，检查是否已经通过glBindAttribLocation指定了绑定。如果指定了绑定，则使用指定的适当属性索引。如果没有，实现将分配一个通用顶点属性索引

For each attribute variable, check if a binding has been specified via  glBindAttribLocation. If a binding is specified, the appropriate attribute index  specified is used. If not, the implementation will assign a generic vertex  attribute index。

这种分配是特定于实现的，并且可能因OpenGL  ES 2.0的实现而异。应用程序可以通过使用glGetAttribLocation命令来查询分配的绑定。

This assignment is implementation specific and can vary from one OpenGL ES 2.0  implementation to another. An application can query the assigned binding by  using the glGetAttribLocation command.

<img src="images/image-20210321205923189.png" alt="image-20210321205923189" style="zoom:50%;" />

当程序定义的程序对象最后一次链接时，glGetAttribLocation返回绑定到属性变量名的通用属性索引。如果名称不是活动的属性变量，或者如果程序不是有效的程序对象或链接不成功，则返回–1，表示无效的属性索引。

glGetAttribLocation returns the generic attribute index bound to attribute  variable name when the program object defined by program was last linked. If  name is not an active attribute variable, or if program is not a valid program  object or was not linked successfully, then –1 is returned, indicating an  invalid attribute index.

## 顶点缓冲对象

Vertex Buffer Objects

使用顶点数组指定的顶点数据存储在客户端内存中。当调用glDrawArrays或glDrawElements时，这些数据必须从客户端内存复制到图形内存。这两个命令在第7章“图元装配和光栅化”中有详细描述然而，它会，

The vertex data specified using vertex arrays is stored in client memory. This  data has to be copied from client memory to graphics memory when a call to  glDrawArrays or glDrawElements is made. These two commands are described in  detail in Chapter 7, “Primitive Assembly and Rasterization.” It would,  however,