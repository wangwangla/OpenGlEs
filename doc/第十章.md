# 第十章

片段着色器之后会应用于帧缓存区或者单个片段的操作，片段着色器的输出是片段的**颜色**和**深度值**，片段之后的操作会影响像素的可见性和最终颜色。

## 缓存区

缓存区有三种，每种缓存区为帧缓存区的每个像素存储不同的数据：

- 色彩  
- 深度
- 模板

缓存区的大小：可以存储每个像素信息的位数；

- 颜色：存储红绿蓝  以及alpha，颜色缓存区为所有组件之和

- 深度和模板：单个值表示缓冲区的位数

  比如16位：5 5 6  

  32位红绿蓝a

颜色缓存区可以是两个缓存区，一个用于显示输出设备（前缓冲区），一个当前没有显示出来的（后缓存区）

然后交换前缓存区和后缓存区来显示新图像。

## 请求附加缓存区

颜色缓存区中包含了深度和模板缓存区，需要在指定EGL的时候请求他们

## 清除缓存区

开始绘制之前我们需要将一切恢复默认值，那么就可以使用glClear()进行操作。参数是一个掩码进行指定。

每个缓存区都有一个默认值，请求清除缓存区的时候使用，每个缓存区可以使用函数进行指定。

- glClear
- glClearDepthf
- glClearStencil

## 掩码对帧缓存的写入

指定帧缓存区的掩码来控制帧缓存区是可以写的，开始之墙需要验证缓存区是否可以写。

写入像素，缓存区将会被更新，指定GL_FALSE和GL_TRUE.

```c
glColorMask(bool red,bool g,bool b,bool a);
```

深度缓存区的写入

```c
glDepthMask(bool depth);
```

但是在渲染半透明的对象时，会禁用对深度缓存区的写入，开始，将渲染场景中的所有不透明对象启用对深度缓存区的写入，不透明的对进行深度排序，绘制半透明的时候可以禁用深度缓存区，当缓存区被禁用，仍然可以读取并用于深度比较，可以保证不透明的对象遮挡住半透明对象，被写入深度缓存区，使得不透明的可以被透明的遮挡。

## 片段的测试和操作

Open GL ES可以用于片段的各种测试，默认的时候，所有的都是被禁用的 ，片段根据写入顺序写入帧缓存区变为像素，通过测试，可以知道那个可以成为像素并影响最终的图像；

可以使用enable（掩码）

## 使用剪刀测试

指定一个矩形区域来限制哪些像素可以写

glScissor（int x,int y,w ,h）；

使用glGenable()启用，它通常是视口的子区域，但是不限制其必须相交。

## 模板缓存区

它是一个没像素的一个掩码，保存可用于确定像素是否应该更新值。

- 用每像素初始化模板缓存区
- 使用这些值来控制颜色缓存区的后续渲染。

## 抖动

您的应用程序对抖动的唯一控制是它是否应用于最终像素















