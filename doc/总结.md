# open gl es

它是一个跨平台的3D图形绘制API，它有1.0和2.0以及3.0版本，1.0采用固定管线，2.0,3.0采用的是可编程接口进行。它的使用过程。首先准备顶点，顶点着色器，片元着色器，它是基于open gl 的，但是它去掉了比较冗余的部分。

## EGL

EGL是opengl 上下文和显示上下文的一个中间部分，它作为两者之前的桥梁，它可以用来创建渲染表面，比如初始化显示器相关的数据，将opengl上下文和他进行绑定，open gl将数据写入帧缓存中，然后通过交换前后缓存区将数据刷新到显示。

首先它需要创建一个绘制绘制表面

- 他与本地窗口进行通信，查询类型和配置
- 创建一个绘制表面
- 创建 一个屏幕外的渲染区域（屏幕不可见像素缓存区，他不是帧缓存区）
- 创建 渲染上下文
- 是的一个环境成文当前的上下文

## 一个完整的案例需要什么

**都是基于2.0的**

首先可编程管线，所以需要准备着色器片段：顶点着色器和片元着色器，下来进行编译，创建程序，加入程序，链接程序，还需要准备顶点数据。使用绘制命令进行绘制。

## opengl的操作流程

准备数据 、片元着色器 、装载图元、光栅化、片段着色器，每一个片段进行操作 。

裁剪测试  模板测试  深度测试  混合 、抖动

## 说一下数据

数据存在java中，但是数据需要在GPU中使用，所以数据需要到一个特殊的区域中，他既可以被 被java操作，也可以被GPU操作，他就是FloatBuffer,数据转换之后，就可以根据句柄传入到open gl中使用。

## 顶点着色器

这个里面可以对位置进行操作，光照计算，通过矩阵变换，将对位置进行矩阵变换。它和片段着色器一样，需要进行编译，然后将编译之后的创建的着色器传递给程序，程序经过加载，链接然后使用。

##  图元 

将数据中的顶点，根据合适的方法，将绘制成基本图元比如三角形，点、线。

## 光栅化

将绘制的图元变为一个个的像素点，在这一个阶段还有一个就是计算差值。

## 片段着色器

片段着色器对每一个片段进行操作，一些特效就是这一部分进行操作的。

## 对每一个片段进行测试

会测试上下文，对属于本上下的进行保留，不属于的进行抛弃

## 裁剪测试

裁剪测试不知道怎么说，举个例子吧，我们绘制一个三维图形，我们只可以看到一个角度，我们这个时候就可以进行才检测测试，创一个小窗口，重新设置相机，绘制出不同角度的效果

## 模板测试

举个例子，加入我在图片上需要绘制一个圆，我们就可以使用模板测试，在这一个部分进行显示。测试通过就通过，测试不通过就不通过。

## 深度测试

我们两个并排站着，我略微在你前面一点，但是我的脚伸到了你的身后，但是这个时候，不设置深度设置，就会看到我伸到你身后的脚，开启之后就看不到了

## 混合

缓存区中的数据和当前数据进行一次混合，使用不同的策略。主要还是对alpha值进行操作。

## 相机

相机位置的设定，类比人的眼睛，我站在哪里，我在头朝向哪里，我看哪里

## 投影

正交投影    透视投影

##  视口

开始位置   宽和高

## transform

对片元着色器中的数据位置进行矩阵变换

## 绘制方式

点  线  三角形

## 背面裁剪

正反面



